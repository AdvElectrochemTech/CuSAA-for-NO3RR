#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
LLM-based semantic mining for Cu-based single-atom catalysts in
nitrate-to-ammonia electroreduction.

Usage example
-------------
python extract_nitrate_SAC.py \
    --input nitrate_reduction_wos.csv \
    --model gpt-4o-mini \
    --batch-size 150
"""

import os
import json
import time
import argparse
from collections import Counter, defaultdict

import pandas as pd
from openai import OpenAI


# ---------- helper functions -------------------------------------------------
def init_client() -> OpenAI:
    """Initialise OpenAI client using the OPENAI_API_KEY environment variable."""
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError("Please set the OPENAI_API_KEY environment variable.")
    return OpenAI(api_key=api_key)


def parse_args():
    parser = argparse.ArgumentParser(
        description=(
            "Batch extraction of Cu-based single-atom/doped catalysts, "
            "performance metrics and mechanistic descriptors from WOS export "
            "for nitrate-to-ammonia electrocatalysis."
        )
    )
    parser.add_argument(
        "--input",
        required=True,
        help="Path to input CSV with columns 'Article Title' and 'Abstract'.",
    )
    parser.add_argument(
        "--batch-size",
        type=int,
        default=200,
        help="Number of records per LLM request (smaller value → lower token cost).",
    )
    parser.add_argument(
        "--model",
        default="gpt-4o",
        help="OpenAI chat model to use (e.g. gpt-4o, gpt-3o).",
    )
    parser.add_argument(
        "--temperature",
        type=float,
        default=0.0,
        help="LLM sampling temperature (0 → deterministic).",
    )
    return parser.parse_args()


def call_llm(client: OpenAI, model: str, prompt: str, temperature: float = 0.0) -> str:
    """Send prompt to the LLM with simple retry logic."""
    for attempt in range(3):
        try:
            resp = client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": "You are an accurate scientific extractor."},
                    {"role": "user", "content": prompt},
                ],
                temperature=temperature,
                timeout=90.0,
            )
            return resp.choices[0].message.content.strip()
        except Exception as exc:
            print(f"LLM call failed (attempt {attempt+1}/3): {exc}")
            time.sleep(5)
    raise RuntimeError("LLM call failed after 3 retries.")


# ---------- main extraction routine ------------------------------------------
def main():
    args = parse_args()
    client = init_client()

    # ---------- read data -----------------------------------------------------
    df = pd.read_csv(args.input, encoding="utf-8-sig")
    if {"Article Title", "Abstract"}.difference(df.columns):
        raise RuntimeError("Input CSV must contain 'Article Title' and 'Abstract' columns.")

    # ---------- counters / collectors ----------------------------------------
    metal_counter = Counter()
    descriptor_counter = Counter()
    perf_records = []

    # ---------- iterate over batches -----------------------------------------
    n_total = len(df)
    n_batches = (n_total + args.batch_size - 1) // args.batch_size
    for batch_idx in range(n_batches):
        batch = df.iloc[batch_idx * args.batch_size : (batch_idx + 1) * args.batch_size]
        items = [
            f"Title: {row['Article Title']}\nAbstract: {row['Abstract']}"
            for _, row in batch.iterrows()
        ]

        prompt = (
            f"You are a research chemist specialising in Cu-based single-atom catalysts "
            f"for electrochemical nitrate reduction to ammonia.\n"
            f"From the following {len(items)} papers (title + abstract), extract:\n"
            f"1) Cu–M single-atom or doped systems (write as 'Ni-Cu', 'Fe-Cu'). "
            f"   Only include cases where Cu is the primary host and M is a single metal dopant.\n"
            f"2) Performance metrics for ammonia production: Faradaic efficiency "
            f"   (FE_NH3, in %), partial current density j_NH3 (mA cm^-2), "
            f"   test potential E_test (vs RHE, V), and turnover frequency TOF (if stated).\n"
            f"   Return a list of JSON objects with keys: catalyst, FE_NH3, j_NH3, "
            f"   E_test, TOF.\n"
            f"3) Mechanistic or theoretical descriptors explicitly mentioned, e.g. "
            f"'ΔG*H', 'ΔG*NO→*NOH', 'd-band centre', 'Bader charge'.\n\n"
            f"Return STRICTLY in the following JSON format:\n"
            f"{{\n"
            f'  "doped_metals":   [ <strings> ],\n'
            f'  "performance":    [ <objects> ],\n'
            f'  "descriptors":    [ <strings> ]\n'
            f"}}\n\n"
            + "\n\n".join(items)
        )

        try:
            response_text = call_llm(client, args.model, prompt, args.temperature)
            data = json.loads(response_text)
        except Exception as exc:
            print(f"[Batch {batch_idx+1}/{n_batches}] skipped due to error: {exc}")
            continue

        # ---------- update statistics ----------------------------------------
        metal_counter.update(data.get("doped_metals", []))
        descriptor_counter.update(data.get("descriptors", []))
        perf_records.extend(data.get("performance", []))

        print(f"[Batch {batch_idx+1}/{n_batches}] processed "
              f"({len(batch)} papers).")

    # ---------- export results -----------------------------------------------
    # 1) doped metals frequency
    df_metals = (
        pd.DataFrame(metal_counter.items(), columns=["Doped_Metal", "Count"])
        .sort_values("Count", ascending=False)
    )
    df_metals.to_csv("doped_metals_frequency.csv", index=False)

    # 2) performance metrics (one row per paper / catalyst)
    if perf_records:
        df_perf = pd.DataFrame(perf_records)
        df_perf.to_csv("performance_metrics.csv", index=False)
    else:
        print("No performance metrics extracted.")

    # 3) descriptor frequency
    df_desc = (
        pd.DataFrame(descriptor_counter.items(), columns=["Descriptor", "Count"])
        .sort_values("Count", ascending=False)
    )
    df_desc.to_csv("descriptors_frequency.csv", index=False)

    print("\n=== Extraction complete ===")
    print(f"  Metals file:       doped_metals_frequency.csv")
    print(f"  Performance file:  performance_metrics.csv")
    print(f"  Descriptors file:  descriptors_frequency.csv")


if __name__ == "__main__":
    main()
